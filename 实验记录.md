# 常用命令

## . ~/venv-revizor/bin/activate

## 执行针对v1的快速测试
python3 revizor.py fuzz -s base.json -i 50 -n 1000 -c tests/configs/config.yaml -w quick-test-v1-wd

## big-fuzzing
python3 revizor.py fuzz -s base.json -c demo/big-fuzz.yaml -i 100 -n 100000000 --timeout 14400 -w wd-big-fuzzing --nonstop

## 使用v1-mutate-test.yaml进行测试
python3 revizor.py fuzz -s base.json -c tests/configs/v1-mutate-test.yaml -n 1000 -i 100 -w wd-v1 --nonstop

# 硬件轨迹阅读 
硬件轨迹会展示两个输入，也就是触发了反例的那两个，每个输入会收集500条硬件轨迹，会统计每一类的出现次数，最后合并比较

# 针对v1的快速测试的调用流程
revizor.py -> cli.py main() -> factory.py get_fuzzer() basic -> 返回X86Fuzzer()对象 -> 调用父类函数start_random()
## start_random()
initialize_modules()  
为self.generation_function赋值
调用X86Fuzzer()类中的 _start() 并非直接调用父类中的，先检查指令集中是否有能触发fault的指令，然后X86Fuzzer()对象调用父类的_start()
## FuzzerGeneric()类 _start() 
首先通过generator.py中的create_test_case()创建测试用例
然后通过input_generator.py generator()创建输入
然后通过X86Fuzzer()类中的filter()来完成推测和观测过滤器
然后调用FuzzerGeneric()类 fuzzing_round()
### FuzzerGeneric()类 fuzzing_round()
首先调用model.py load_test_case()以及x86_executor.py load_test_case()加载测试用例
<br>首先快速路径<br>
然后调用fuzzer.py _boost_inputs()来生成等价输入  
之后调用_collect_traces()来收集合约轨迹和硬件轨迹，并判断是否发现违规。未发现则直接返回，发现则进入慢速路径判断是否是假阳性
<br>慢速路径 用于排除误报<br>
2.1 启用最大深度的嵌套层数，以排除由于嵌套过浅带来的误报  
这一步会重新生成 增强输入  
2.2 误报也可能源于污点分析的不精确  
在 fast boosting 模式下，多个输入共享同一个 contract trace  
用完整的 trace（禁用 fast boosting）重新比较 contract trace。  
若 violation 消失，说明 fast boosting 错误引发的 FP。  
2.3 误报来源于输入间的相互干扰  
启用priming  
2.4 噪声  
启用最大测试次数（硬件轨迹500次）  
启用priming  
2.5 模型与硬件不一致  
调用 is_architectural_mismatch() 函数对比模型与实际架构是否一致，该函数比较的是寄存器的值


# util.py dbg_report_coverage()
添加 self.dbg_coverage = True  

# 变异
ABSynthe  
BETA 仔细研究一下
DIFFUZZ 记录两个测试用例的差异以及得分  
FeedbackFuzz  
PCBleed 我们支持五种类型的变异：交换指令、变异指令、变异指令的操作数、插入指令和删除指令。在交换指令时，我们在基本块中随机选择两条指令并进行交换，同时确保没有悬空指针。第二种变异类型是指令变异，随机选择一条指令并用 ISA 子集中不是终止符的指令替换它。第三种类型是操作数变异，随机选择一条指令并变异其操作数，但保持操作码不变。最后，插入和删除指令通过随机选择要插入或删除的指令来变异基本块。鉴于上述定义，我们采用了以下方法来变异基本块（受 SurgeFuzz 的启发）：我们随机决定是选择变异类型并将其应用于基本块的循环中，还是在循环中选择变异类型并将其应用于基本块  
Processor Fuzzing with Control and Status Registers Guidance 使用了与 DIFUZZRTL 开源代码库相同的变异引擎
SIGFuzz 用nop逐一替换指令
SpecDoctor 随机替换、移除或附加测试用例中的一条指令  
TheHuzz   
WhisperFuzz










# X86Fuzzer()的filter()函数完成了推测过滤器和观测过滤器的功能
## 和pfc的交互还需要看一下，尤其是收集了哪些指标以及这些指标是怎么作为推测过滤的判定条件的


# class ArchitecturalFuzzer(FuzzerGeneric)
这个类可以用于检查架构不匹配问题



python3 revizor.py tfuzz -s base.json -c tests/configs/v1-mutate-test.yaml -n 5 -i 100 -w wd-tfuzz -t wd-v1/violation-250827-213422/program.asm --nonstop

python3 revizor.py mutate -s base.json -c tests/configs/v1-mutate-test.yaml -n 1 -i 100 -w wd-mutate -t s1-test/s1-test.asm --nonstop